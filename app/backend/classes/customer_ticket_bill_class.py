from sqlalchemy.orm import Session
from app.backend.db.models import DteModel, CustomerModel, BranchOfficeModel, UserModel, ExpenseTypeModel, SupplierModel
from app.backend.classes.customer_class import CustomerClass
from app.backend.classes.helper_class import HelperClass
from app.backend.classes.file_class import FileClass
from sqlalchemy import desc
from sqlalchemy.dialects import mysql
from sqlalchemy import or_
from datetime import datetime
from fastapi import HTTPException
import requests
import json
import base64
import uuid
from sqlalchemy.sql import func

class CustomerTicketBillClass:
    def __init__(self, db: Session):
        self.db = db
        self.file_class = FileClass(db)  # Crear una instancia de FileClass

    def get_all(self, rol_id = None, rut = None, page=1, items_per_page=10):
        try:

            if rol_id == 1 or rol_id == 2:
                # Inicialización de filtros dinámicos
                filters = []

                filters.append(DteModel.dte_version_id == 1)
                filters.append(DteModel.status_id > 3)
                filters.append(DteModel.status_id < 16)
                filters.append(DteModel.rut != None)
                filters.append(DteModel.rut != '66666666-6')
                filters.append(or_(DteModel.dte_type_id == 33, DteModel.dte_type_id == 39))

                # Construir la consulta base con los filtros aplicados
                query = self.db.query(
                        DteModel.id, 
                        DteModel.branch_office_id, 
                        DteModel.dte_type_id, 
                        DteModel.folio, 
                        DteModel.total,
                        DteModel.added_date,
                        DteModel.rut,
                        DteModel.status_id,
                        DteModel.chip_id,
                        DteModel.payment_date,
                        BranchOfficeModel.branch_office,
                        CustomerModel.customer.label('customer')
                ).outerjoin(
                    BranchOfficeModel, BranchOfficeModel.id == DteModel.branch_office_id
                ).outerjoin(
                    CustomerModel, CustomerModel.rut == DteModel.rut
                ).filter(
                    *filters
                ).order_by(
                    DteModel.added_date.desc()
                )
            elif rol_id == 4:
                                # Inicialización de filtros dinámicos
                filters = []

                filters.append(DteModel.dte_version_id == 1)
                filters.append(DteModel.status_id > 3)
                filters.append(DteModel.status_id < 16)
                filters.append(DteModel.rut != None)
                filters.append(DteModel.rut != '66666666-6')
                filters.append(or_(DteModel.dte_type_id == 33, DteModel.dte_type_id == 39))

                # Construir la consulta base con los filtros aplicados
                query = self.db.query(
                        DteModel.id, 
                        DteModel.branch_office_id, 
                        DteModel.dte_type_id, 
                        DteModel.folio, 
                        DteModel.total,
                        DteModel.added_date,
                        DteModel.rut,
                        DteModel.status_id,
                        DteModel.payment_date,
                        DteModel.chip_id,
                        BranchOfficeModel.branch_office,
                        CustomerModel.customer.label('customer')
                ).outerjoin(
                    BranchOfficeModel, BranchOfficeModel.id == DteModel.branch_office_id
                ).outerjoin(
                    CustomerModel, CustomerModel.rut == DteModel.rut
                ).filter(
                    BranchOfficeModel.principal_supervisor == rut
                ).filter(
                    *filters
                ).order_by(
                    DteModel.added_date.desc()
                )

            # Si se solicita paginación
            if page > 0:
                # Calcular el total de registros
                total_items = query.count()
                total_pages = (total_items + items_per_page - 1) // items_per_page
                if page < 1 or page > total_pages:
                    return {"status": "error", "message": "Invalid page number"}

                # Aplicar paginación en la consulta
                data = query.offset((page - 1) * items_per_page).limit(items_per_page).all()

                if not data:
                    return {"status": "error", "message": "No data found"}

                # Serializar los datos
                serialized_data = [{
                    "id": dte.id,
                    "rut": dte.rut,
                    "branch_office_id": dte.branch_office_id,
                    "dte_type_id": dte.dte_type_id,
                    "customer": dte.customer,
                    "chip_id": dte.chip_id,
                    "folio": dte.folio,
                    "total": dte.total,
                    "payment_date": dte.payment_date,
                    "status_id": dte.status_id,
                    "added_date": dte.added_date.strftime('%d-%m-%Y') if dte.added_date else None,
                    "branch_office": dte.branch_office
                } for dte in data]

                return {
                    "total_items": total_items,
                    "total_pages": total_pages,
                    "current_page": page,
                    "items_per_page": items_per_page,
                    "data": serialized_data
                }

            # Si no se solicita paginación, traer todos los datos
            else:
                data = query.all()

                # Serializar los datos
                serialized_data = [{
                    "id": dte.id,
                    "rut": dte.rut,
                    "branch_office_id": dte.branch_office_id,
                    "customer": dte.customer,
                    "chip_id": dte.chip_id,
                    "folio": dte.folio,
                    "total": dte.total,
                    "added_date": dte.added_date.strftime('%d-%m-%Y') if dte.added_date else None,
                    "payment_date": dte.payment_date,
                    "branch_office": dte.branch_office,
                    "status_id": dte.status_id
                } for dte in data]

                return serialized_data

        except Exception as e:
            error_message = str(e)
            return {"status": "error", "message": error_message}

    def search(self, branch_office_id=None, rut=None, status_id=None, supervisor_id=None, page=0, items_per_page=10):
        try:
            # Inicialización de filtros dinámicos
            filters = []

            if branch_office_id != None and branch_office_id != "":
                filters.append(DteModel.branch_office_id == branch_office_id)
            if rut != None and rut != "":
                filters.append(DteModel.rut == rut)
            if status_id != None and status_id != "":
                filters.append(DteModel.status_id == status_id)
            if supervisor_id != None and supervisor_id != "":
                filters.append(UserModel.supervisor_id == supervisor_id)

            filters.append(DteModel.dte_version_id == 1)
            filters.append(DteModel.status_id > 3)
            filters.append(DteModel.rut != None)
            filters.append(DteModel.rut != '66666666-6')
            
            if supervisor_id != None:
                # Construir la consulta base con los filtros aplicados
                query = self.db.query(
                    DteModel.id, 
                    DteModel.branch_office_id, 
                    DteModel.folio, 
                    DteModel.total,
                    DteModel.added_date,
                    DteModel.rut,
                    DteModel.status_id,
                    DteModel.chip_id,
                    DteModel.payment_date,
                    CustomerModel.customer,
                    BranchOfficeModel.branch_office
                ).outerjoin(
                    BranchOfficeModel, BranchOfficeModel.id == DteModel.branch_office_id
                ).outerjoin(
                    UserModel, UserModel.rut == BranchOfficeModel.principal_supervisor
                ).outerjoin(
                    CustomerModel, CustomerModel.rut == DteModel.rut
                ).filter(
                    *filters
                ).order_by(
                    desc(DteModel.folio)
                )
            else:
                # Construir la consulta base con los filtros aplicados
                query = self.db.query(
                    DteModel.id, 
                    DteModel.branch_office_id, 
                    DteModel.folio, 
                    DteModel.total,
                    DteModel.added_date,
                    DteModel.rut,
                    DteModel.status_id,
                    DteModel.payment_date,
                    DteModel.chip_id,
                    CustomerModel.customer,
                    BranchOfficeModel.branch_office
                ).outerjoin(
                    BranchOfficeModel, BranchOfficeModel.id == DteModel.branch_office_id
                ).outerjoin(
                    CustomerModel, CustomerModel.rut == DteModel.rut
                ).filter(
                    *filters
                ).order_by(
                    desc(DteModel.folio)
                )

            # Si se solicita paginación
            if page > 0:
                # Calcular el total de registros
                total_items = query.count()
                print(query.statement.compile(dialect=mysql.dialect(), compile_kwargs={"literal_binds": True}))

                total_pages = (total_items + items_per_page - 1) // items_per_page
                print(total_pages)
                if page < 1 or page > total_pages:
                    return {"status": "error", "message": "Invalid page number"}

                # Aplicar paginación en la consulta
                data = query.offset((page - 1) * items_per_page).limit(items_per_page).all()

                if not data:
                    return {"status": "error", "message": "No data found"}

                # Serializar los datos
                serialized_data = [{
                    "id": dte.id,
                    "rut": dte.rut,
                    "branch_office_id": dte.branch_office_id,
                    "payment_date": dte.payment_date,
                    "customer": dte.customer,
                    "chip_id": dte.chip_id,
                    "folio": dte.folio,
                    "total": dte.total,
                    "status_id": dte.status_id,
                    "added_date": dte.added_date.strftime('%d-%m-%Y') if dte.added_date else None,
                    "branch_office": dte.branch_office
                } for dte in data]

                return {
                    "total_items": total_items,
                    "total_pages": total_pages,
                    "current_page": page,
                    "items_per_page": items_per_page,
                    "data": serialized_data
                }

            # Si no se solicita paginación, traer todos los datos
            else:
                data = query.all()

                # Serializar los datos
                serialized_data = [{
                    "id": dte.id,
                    "rut": dte.rut,
                    "branch_office_id": dte.branch_office_id,
                    "customer": dte.customer,
                    "payment_date": dte.payment_date,
                    "folio": dte.folio,
                    "chip_id": dte.chip_id,
                    "total": dte.total,
                    "added_date": dte.added_date.strftime('%d-%m-%Y') if dte.added_date else None,
                    "branch_office": dte.branch_office,
                    "status_id": dte.status_id
                } for dte in data]

                return serialized_data

        except Exception as e:
            error_message = str(e)
            return {"status": "error", "message": error_message}
    
    def get_all_to_review(self, rol_id = None, rut = None, page=1, items_per_page=10):
        try:
            if rol_id == 1 or rol_id == 2:
                # Inicialización de filtros dinámicos
                filters = []

                filters.append(DteModel.dte_version_id == 1)
                filters.append(DteModel.status_id == 16)
                filters.append(DteModel.rut != None)
                filters.append(DteModel.rut != '66666666-6')
                filters.append(or_(DteModel.dte_type_id == 33, DteModel.dte_type_id == 39))

                # Construir la consulta base con los filtros aplicados
                query = self.db.query(
                        DteModel.id, 
                        DteModel.branch_office_id, 
                        DteModel.dte_type_id, 
                        DteModel.folio, 
                        DteModel.total,
                        DteModel.added_date,
                        DteModel.rut,
                        DteModel.status_id,
                        DteModel.chip_id,
                        DteModel.payment_date,
                        BranchOfficeModel.branch_office,
                        CustomerModel.customer.label('customer')
                ).outerjoin(
                    BranchOfficeModel, BranchOfficeModel.id == DteModel.branch_office_id
                ).outerjoin(
                    CustomerModel, CustomerModel.rut == DteModel.rut
                ).filter(
                    *filters
                ).order_by(
                    DteModel.added_date.desc()
                )
            elif rol_id == 4:
                                # Inicialización de filtros dinámicos
                filters = []

                filters.append(DteModel.dte_version_id == 1)
                filters.append(DteModel.status_id == 16)
                filters.append(DteModel.rut != None)
                filters.append(DteModel.rut != '66666666-6')
                filters.append(or_(DteModel.dte_type_id == 33, DteModel.dte_type_id == 39))

                # Construir la consulta base con los filtros aplicados
                query = self.db.query(
                        DteModel.id, 
                        DteModel.branch_office_id, 
                        DteModel.dte_type_id, 
                        DteModel.folio, 
                        DteModel.total,
                        DteModel.added_date,
                        DteModel.rut,
                        DteModel.status_id,
                        DteModel.payment_date,
                        DteModel.chip_id,
                        BranchOfficeModel.branch_office,
                        CustomerModel.customer.label('customer')
                ).outerjoin(
                    BranchOfficeModel, BranchOfficeModel.id == DteModel.branch_office_id
                ).outerjoin(
                    CustomerModel, CustomerModel.rut == DteModel.rut
                ).filter(
                    BranchOfficeModel.principal_supervisor == rut
                ).filter(
                    *filters
                ).order_by(
                    DteModel.added_date.desc()
                )

            # Si se solicita paginación
            if page > 0:
                # Calcular el total de registros
                total_items = query.count()
                total_pages = (total_items + items_per_page - 1) // items_per_page
                if page < 1 or page > total_pages:
                    return {"status": "error", "message": "Invalid page number"}

                # Aplicar paginación en la consulta
                data = query.offset((page - 1) * items_per_page).limit(items_per_page).all()

                if not data:
                    return {"status": "error", "message": "No data found"}

                # Serializar los datos
                serialized_data = [{
                    "id": dte.id,
                    "rut": dte.rut,
                    "branch_office_id": dte.branch_office_id,
                    "dte_type_id": dte.dte_type_id,
                    "customer": dte.customer,
                    "chip_id": dte.chip_id,
                    "folio": dte.folio,
                    "total": dte.total,
                    "payment_date": dte.payment_date,
                    "status_id": dte.status_id,
                    "added_date": dte.added_date.strftime('%d-%m-%Y') if dte.added_date else None,
                    "branch_office": dte.branch_office
                } for dte in data]

                return {
                    "total_items": total_items,
                    "total_pages": total_pages,
                    "current_page": page,
                    "items_per_page": items_per_page,
                    "data": serialized_data
                }

            # Si no se solicita paginación, traer todos los datos
            else:
                data = query.all()

                # Serializar los datos
                serialized_data = [{
                    "id": dte.id,
                    "rut": dte.rut,
                    "branch_office_id": dte.branch_office_id,
                    "customer": dte.customer,
                    "chip_id": dte.chip_id,
                    "folio": dte.folio,
                    "total": dte.total,
                    "added_date": dte.added_date.strftime('%d-%m-%Y') if dte.added_date else None,
                    "payment_date": dte.payment_date,
                    "branch_office": dte.branch_office,
                    "status_id": dte.status_id
                } for dte in data]

                return serialized_data

        except Exception as e:
            error_message = str(e)
            return {"status": "error", "message": error_message}
    
    def update(self, form_data):
        """
        Actualiza los datos de la patente en la base de datos.
        """
        dte = self.db.query(DteModel).filter(DteModel.id == form_data.id).first()
        if not dte:
            raise HTTPException(status_code=404, detail="Dte no encontrado")

        # Actualizar campos
        dte.branch_office_id = form_data.branch_office_id
        dte.rut = form_data.rut
        dte.cash_amount = form_data.amount + 5000 if form_data.chip_id == 1 else form_data.amount
        dte.subtotal = round((form_data.amount + 5000)/1.19) if form_data.chip_id == 1 else round((form_data.amount)/1.19)
        dte.tax = (form_data.amount + 5000) - round((form_data.amount + 5000)/1.19) if form_data.chip_id == 1 else form_data.amount - round((form_data.amount)/1.19)
        dte.discount = 0
        dte.total = form_data.amount + 5000 if form_data.chip_id == 1 else form_data.amount
        dte.chip_id = form_data.chip_id
        dte.status_id = 2

        self.db.commit()
        self.db.refresh(dte)
    
    def accept_dte_payment(self, id):
        """
        Actualiza los datos de la patente en la base de datos.
        """
        dte = self.db.query(DteModel).filter(DteModel.id == id).first()
        if not dte:
            raise HTTPException(status_code=404, detail="Dte no encontrado")

        # Actualizar campos
        dte.status_id = 5

        self.db.commit()
        self.db.refresh(dte)

    def reject_dte_payment(self, id):
        """
        Actualiza los datos de la patente en la base de datos.
        """
        dte = self.db.query(DteModel).filter(DteModel.id == id).first()
        if not dte:
            raise HTTPException(status_code=404, detail="Dte no encontrado")

        # Actualizar campos
        dte.payment_type_id = None
        dte.payment_date = None
        dte.payment_amount = None
        dte.payment_number = None
        dte.support = None
        dte.status_id = 4

        self.db.commit()
        self.db.refresh(dte)

    def change_status(self, form_data):
        """
        Actualiza los datos de la patente en la base de datos.
        """
        dte = self.db.query(DteModel).filter(DteModel.id == form_data.id).first()
        if not dte:
            raise HTTPException(status_code=404, detail="Dte no encontrado")

        # Actualizar campos
        dte.expense_type_id = form_data.expense_type_id
        dte.payment_type_id = form_data.payment_type_id
        dte.payment_date = form_data.payment_date
        period = form_data.payment_date.split('-')
        dte.period = period[0] + '-' + period[1]
        dte.comment = form_data.comment
        dte.status_id = 5

        self.db.commit()
        self.db.refresh(dte)

        self.create_account_asset(dte)

    def reject(self, id):
        dte = self.db.query(DteModel).filter(DteModel.id == id).first()
        if not dte:
            raise HTTPException(status_code=404, detail="Dte no encontrado")

        dte.status_id = 3

        self.db.commit()
        self.db.refresh(dte)

    def get(self, id):
        try:
            data_query = self.db.query(DteModel.id, DteModel.payment_type_id, DteModel.denied_folio, DteModel.payment_date, DteModel.payment_amount, DteModel.payment_number, DteModel.support, DteModel.period, DteModel.rut, DteModel.branch_office_id, DteModel.total, CustomerModel.address, DteModel.cash_amount, CustomerModel.customer, CustomerModel.region_id, CustomerModel.commune_id, CustomerModel.activity, CustomerModel.email, CustomerModel.phone, DteModel.chip_id, DteModel.folio, DteModel.status_id, DteModel.added_date, BranchOfficeModel.branch_office). \
                        outerjoin(BranchOfficeModel, BranchOfficeModel.id == DteModel.branch_office_id). \
                        outerjoin(CustomerModel, CustomerModel.rut == DteModel.rut). \
                        filter(DteModel.id == id). \
                        first()

            if data_query:
                # Serializar los datos del empleado
                customer_ticket_data = {
                    "id": data_query.id,
                    "rut": data_query.rut,
                    "branch_office_id": data_query.branch_office_id,
                    "customer": data_query.customer,
                    "email": data_query.email,
                    "phone": data_query.phone,
                    "chip_id": data_query.chip_id,
                    "folio": data_query.folio,
                    "activity": data_query.activity,
                    "denied_folio": data_query.denied_folio,
                    "region_id": data_query.region_id,
                    "commune_id": data_query.commune_id,
                    "address": data_query.address,
                    "total": data_query.total,
                    "status_id": data_query.status_id,
                    "period": data_query.period,
                    "added_date": data_query.added_date.strftime('%d-%m-%Y') if data_query.added_date else None,
                    "branch_office": data_query.branch_office,
                    "payment_type_id": data_query.payment_type_id,
                    "payment_date": data_query.payment_date,
                    "payment_amount": data_query.payment_amount,
                    "payment_number": data_query.payment_number,
                    "support": data_query.support
                }

                # Crear el resultado final como un diccionario
                result = {
                    "customer_ticket_bill_data": customer_ticket_data
                }

                # Convierte el resultado a una cadena JSON
                serialized_result = json.dumps(result)

                return serialized_result

            else:
                return "No se encontraron datos para el campo especificado."

        except Exception as e:
            error_message = str(e)
            return f"Error: {error_message}"
            
    def create_account_asset(self, form_data):
        TOKEN = "JXou3uyrc7sNnP2ewOCX38tWZ6BTm4D1"

        american_date = form_data.period + '-01'
        utf8_date = HelperClass.convert_to_utf8(american_date)
        expense_type = '441000102'
        branch_office = self.db.query(BranchOfficeModel).filter(
            BranchOfficeModel.id == form_data.branch_office_id
        ).first()

        gloss = (
                branch_office.branch_office
                + "_"
                + expense_type
                + "_"
                + utf8_date
                + "_NotaCredito_"
                + str(form_data.id)
                + "_"
                + str(form_data.folio)
            )
        amount = form_data.total
        
        data = {
                "fecha": american_date,
                "glosa": gloss,
                "detalle": {
                    "debe": {
                        expense_type: round(int(amount)/1.19),
                        "221000226": round(int(amount) - (int(amount)/1.19)),
                    },
                    "haber": {
                        "111000102": int(amount),
                    }
                },
                "operacion": "I",
                "documentos": {
                    "emitidos": [
                        {
                            "dte": form_data.dte_type_id,
                            "folio": form_data.folio,
                        }
                    ]
                },
            }

        url = f"https://libredte.cl/api/lce/lce_asientos/crear/" + "76063822"

        response = requests.post(
                url,
                json=data,
                headers={
                    "Authorization": f"Bearer {TOKEN}",
                    "Content-Type": "application/json",
                },
            )

        if response.status_code == 200:
            return "Accounting entry created successfully"
        else:
            return f"Accounting entry creation failed."

    def store_credit_note(self, form_data, rol_id, is_massive_sending=False):
        dte = self.db.query(DteModel).filter(DteModel.id == form_data.id).first()
        
        customer = CustomerClass(self.db).get_by_rut(dte.rut)
        
        # Verificar si customer es un JSON válido
        try:
            customer_data = json.loads(customer)
            if not isinstance(customer_data, dict) or 'customer_data' not in customer_data:
                return f"Error: Invalid customer data format for RUT {dte.rut}"
        except json.JSONDecodeError as e:
            return f"Error: Invalid JSON from customer lookup for RUT {dte.rut}: {customer}"

        # Obtener el folio del DTE consultado (común para ambos roles)
        original_dte_folio = None
        original_dte_type_id = None
        original_dte = None  # DTE original (factura/boleta) para obtener su sucursal
        
        # Si el DTE consultado es una factura/boleta (33 o 39), usarlo directamente como original
        if dte.dte_type_id in [33, 39] and dte.folio and dte.folio > 0:
            original_dte_folio = dte.folio
            original_dte_type_id = dte.dte_type_id
            original_dte = dte
        elif dte.denied_folio:
            # Si tiene denied_folio, buscar el DTE original (factura/boleta)
            original_dte_query = self.db.query(DteModel).filter(
                DteModel.folio == dte.denied_folio,
                DteModel.dte_type_id.in_([33, 39])
            ).first()
            if original_dte_query and original_dte_query.folio:
                original_dte_folio = original_dte_query.folio
                original_dte_type_id = original_dte_query.dte_type_id
                original_dte = original_dte_query
            else:
                # Si no se encuentra, usar el denied_folio como original_dte_folio
                original_dte_folio = dte.denied_folio
                original_dte_type_id = dte.dte_type_id
        elif dte.folio and dte.folio > 0:
            # Si tiene folio pero no es 33/39 ni tiene denied_folio, buscar el DTE original por folio
            original_dte = self.db.query(DteModel).filter(
                DteModel.folio == dte.folio,
                DteModel.dte_type_id.in_([33, 39])
            ).first()
            if original_dte:
                original_dte_folio = original_dte.folio
                original_dte_type_id = original_dte.dte_type_id
            else:
                # Si no se encuentra, usar el folio del DTE consultado
                original_dte_folio = dte.folio
                original_dte_type_id = dte.dte_type_id
        
        # Determinar la sucursal: usar la del DTE original si existe, sino la del DTE consultado
        branch_office_id_to_use = original_dte.branch_office_id if original_dte else dte.branch_office_id


        # Si es rol 4 (supervisor), solo crear la nota de crédito con status 14
        if rol_id == 4:
            added_date = dte.added_date
            if added_date:
                period = added_date.strftime('%Y-%m')
            else:
                period = datetime.now().strftime('%Y-%m')

            try:
                validate_credit_note_count = self.db.query(DteModel).filter(
                    DteModel.dte_type_id == 61,
                    DteModel.denied_folio == original_dte_folio,
                    DteModel.status_id == 14
                ).count()

                if validate_credit_note_count > 0:
                    return {
                        "status": "error",
                        "message": "A credit note with this denied_folio already exists"
                    }
                
                credit_note_dte = DteModel()
                        
                # Asignar los valores del formulario a la instancia del modelo
                credit_note_dte.branch_office_id = branch_office_id_to_use
                credit_note_dte.cashier_id = 0
                credit_note_dte.dte_type_id = 61
                credit_note_dte.dte_version_id = 1
                credit_note_dte.status_id = 14  # Status 14 para supervisores
                credit_note_dte.chip_id = 0
                credit_note_dte.rut = customer_data['customer_data']['rut']
                credit_note_dte.folio = 0  # Sin folio para status 14
                credit_note_dte.denied_folio = original_dte_folio  # Guardar el folio original en denied_folio
                credit_note_dte.reason_id = form_data.reason_id  # Guardar el motivo de la nota de crédito
                credit_note_dte.cash_amount = -abs(int(dte.cash_amount))
                credit_note_dte.card_amount = 0
                credit_note_dte.subtotal = -abs(round(int(dte.cash_amount)/1.19))
                credit_note_dte.tax = -abs(int(dte.cash_amount) - round(int(dte.cash_amount)/1.19))
                credit_note_dte.discount = 0
                credit_note_dte.total = -abs(int(dte.cash_amount))
                credit_note_dte.period = period
                credit_note_dte.added_date = dte.added_date

                self.db.add(credit_note_dte)
                self.db.commit()
                
                return {
                    "status": "success",
                    "message": "Credit note created with status 14",
                    "credit_note_id": credit_note_dte.id,
                    "denied_folio": original_dte_folio
                }
            except Exception as e:
                self.db.rollback()
                return {
                    "status": "error",
                    "message": f"Error creating credit note: {str(e)}",
                    "error_type": type(e).__name__
                }

        # Proceso completo para roles 1 y 2
        elif rol_id == 1 or rol_id == 2:
            # Si el folio es 0, usar la fecha del DTE desde la base de datos
            if dte.folio == 0:
                dte_date = dte.added_date.strftime('%Y-%m-%d') if dte.added_date else datetime.now().strftime('%Y-%m-%d')
            else:
                dte_date = self.get_dte_date(dte.dte_type_id, dte.folio)
            # Obtener el dte_code de la sucursal para incluir en la nota de crédito
            branch_office_for_dte = self.db.query(BranchOfficeModel).filter(BranchOfficeModel.id == branch_office_id_to_use).first()
            dte_code = branch_office_for_dte.dte_code if branch_office_for_dte else None
            
            code = self.pre_generate_credit_note_ticket(customer_data, original_dte_type_id, original_dte_folio, dte.cash_amount, dte_date, dte_code)
            folio = None

            if code is not None:
                if code == 402:
                    return "LibreDTE payment required"

                folio = self.generate_credit_note_ticket(customer_data['customer_data']['rut'], code, dte.dte_type_id)

            if folio != None:
                # Si viene del envío masivo, actualizar el DTE original y retornar el folio
                if is_massive_sending:
                    # Actualizar el DTE original (33 o 39) a status 5
                    if original_dte_folio and original_dte_folio > 0:
                        original_dte_to_update = self.db.query(DteModel).filter(
                            DteModel.folio == original_dte_folio,
                            or_(DteModel.dte_type_id == 33, DteModel.dte_type_id == 39)
                        ).first()
                        if original_dte_to_update:
                            original_dte_to_update.status_id = 5
                            self.db.add(original_dte_to_update)
                            self.db.commit()
                    return folio  # Retornar solo el folio generado
                
                # Verificar si ya existe una nota de crédito con este denied_folio
                existing_credit_note = self.db.query(DteModel).filter(
                    DteModel.dte_type_id == 61,
                    DteModel.denied_folio == original_dte_folio
                ).first()

                added_date = dte_date
                period = added_date.split(' ')
                period = period[0].split('-')
                period = period[0] + '-' + period[1]

                try:
                    if existing_credit_note:
                        # Actualizar la nota de crédito existente
                        existing_credit_note.branch_office_id = branch_office_id_to_use
                        existing_credit_note.rut = customer_data['customer_data']['rut']
                        existing_credit_note.folio = folio
                        existing_credit_note.reason_id = form_data.reason_id
                        existing_credit_note.cash_amount = -abs(int(dte.cash_amount))
                        existing_credit_note.subtotal = -abs(round(int(dte.cash_amount)/1.19))
                        existing_credit_note.tax = -abs(int(dte.cash_amount) - round(int(dte.cash_amount)/1.19))
                        existing_credit_note.total = -abs(int(dte.cash_amount))
                        existing_credit_note.period = period
                        existing_credit_note.status_id = 5

                        self.db.add(existing_credit_note)
                        
                        action_message = "Credit note updated successfully"
                        credit_note_id = existing_credit_note.id
                    else:
                        # Crear nueva nota de crédito
                        credit_note_dte = DteModel()
                                
                        # Asignar los valores del formulario a la instancia del modelo
                        credit_note_dte.branch_office_id = branch_office_id_to_use
                        credit_note_dte.cashier_id = 0
                        credit_note_dte.dte_type_id = 61
                        credit_note_dte.dte_version_id = 1
                        credit_note_dte.status_id = 5
                        credit_note_dte.chip_id = 0
                        credit_note_dte.rut = customer_data['customer_data']['rut']
                        credit_note_dte.folio = folio
                        credit_note_dte.denied_folio = original_dte_folio  # Guardar el folio original en denied_folio
                        credit_note_dte.reason_id = form_data.reason_id  # Guardar el motivo de la nota de crédito
                        credit_note_dte.cash_amount = -abs(int(dte.cash_amount))
                        credit_note_dte.card_amount = 0
                        credit_note_dte.subtotal = -abs(round(int(dte.cash_amount)/1.19))
                        credit_note_dte.tax = -abs(int(dte.cash_amount) - round(int(dte.cash_amount)/1.19))
                        credit_note_dte.discount = 0
                        credit_note_dte.total = -abs(int(dte.cash_amount))
                        credit_note_dte.period = period
                        credit_note_dte.added_date = dte.added_date

                        self.db.add(credit_note_dte)
                        
                        action_message = "Credit note created successfully"
                        credit_note_id = credit_note_dte.id

                    # Actualizar el DTE actual a status 5
                    dte.status_id = 5
                    dte.reason_id = form_data.reason_id
                    dte.comment = 'Código de autorización: Nota de Crédito ' + str(code)
                    self.db.add(dte)
                    
                    # Actualizar el DTE original (33 o 39) a status 5 si existe y es diferente al actual
                    if original_dte_folio and original_dte_folio > 0 and original_dte_folio != dte.folio:
                        original_dte_to_update = self.db.query(DteModel).filter(
                            DteModel.folio == original_dte_folio,
                            or_(DteModel.dte_type_id == 33, DteModel.dte_type_id == 39)
                        ).first()
                        if original_dte_to_update:
                            original_dte_to_update.status_id = 5
                            self.db.add(original_dte_to_update)
                    
                    self.db.commit()

                    return {
                        "status": "success",
                        "message": action_message,
                        "credit_note_id": credit_note_id,
                        "folio": folio,
                        "denied_folio": original_dte_folio,
                        "original_dte_updated": original_dte_folio != dte.folio
                    }
                except Exception as e:
                    self.db.rollback()
                    return {
                        "status": "error",
                        "message": f"Error creating/updating credit note: {str(e)}",
                        "error_type": type(e).__name__
                    }
            else:
                return {
                    "status": "error",
                    "message": "Error generating credit note - folio is None",
                    "error_type": "GenerationError"
                }
        else:
            return {
                "status": "error", 
                "message": "Unauthorized role for this operation",
                "error_type": "AuthorizationError"
            }
    
    def get_dte_date(self, dte_type_id, folio):
        TOKEN = "JXou3uyrc7sNnP2ewOCX38tWZ6BTm4D1"

        # Endpoint para generar un DTE temporal
        url = f"https://libredte.cl/api/dte/dte_emitidos/info/"+ str(dte_type_id) +"/" + str(folio) + '/76063822?getXML=0&getDetalle=0&getDatosDte=0&getTed=0&getResolucion=0&getEmailEnviados=0&getLinks=0&getReceptor=0&getSucursal=0&getUsuario=0'
            
        # Enviar solicitud a la API
        response = requests.get(
            url,
            headers={
                "Authorization": f"Bearer {TOKEN}",
                "Content-Type": "application/json",
            },
        )

        response_data = response.json()

        return response_data['fecha']

    def pre_generate_credit_note_ticket(self, customer_data, dte_type_id, folio, cash_amount, added_date, dte_code=None):  # Added self as the first argument
        TOKEN = "JXou3uyrc7sNnP2ewOCX38tWZ6BTm4D1"

        print(cash_amount)

        amount = round(abs(int(cash_amount))/1.19)

        try:
            pass
        except Exception as e:
            print(f"ERROR accediendo a customer_data: {str(e)}")
            print(f"customer_data keys: {list(customer_data.keys()) if hasattr(customer_data, 'keys') else 'No keys method'}")
        
        # Construir el objeto Emisor con o sin sucursal
        emisor_data = {
            "RUTEmisor": "76063822-6"
        }
        if dte_code:
            emisor_data['CdgSIISucur'] = dte_code
            
        data = {
                "Encabezado": {
                    "IdDoc": {
                        "TipoDTE": 61,
                        "FchEmis": added_date,
                        "TpoTranVenta": 1,
                        "FmaPago": "1",
                    },
                    "Emisor": emisor_data,
                    "Receptor": {
                        "RUTRecep": customer_data['customer_data']['rut'],
                        "RznSocRecep": customer_data['customer_data']['customer'],
                        "GiroRecep": customer_data['customer_data']['activity'],
                        "DirRecep": customer_data['customer_data']['region'],
                        "CmnaRecep": customer_data['customer_data']['commune'],
                    }
                },
                "Detalle": [
                    {
                        "NmbItem": "Nota de Crédito de Venta",
                        "QtyItem": 1,
                        "PrcItem": amount,
                        "MontoItem": amount,
                    }
                ],
                "Referencia": [ {
                    "TpoDocRef": dte_type_id,
                    "FolioRef": folio,
                    "FchRef": added_date,
                    "CodRef": 1,
                    "RazonRef": "Anula factura o boleta"
                }],
            }
        
        print(data)

        try:
            # Endpoint para generar un DTE temporal
            url = f"https://libredte.cl/api/dte/documentos/emitir?normalizar=1&formato=json&links=0&email=0"
            
            # Enviar solicitud a la API
            response = requests.post(
                url,
                json=data,
                headers={
                    "Authorization": f"Bearer {TOKEN}",
                    "Content-Type": "application/json",
                },
            )

            # Manejar la respuesta
            if response.status_code == 200:
                dte_data = response.json()
                code = dte_data.get("codigo")

                return code
            else:
                return response.status_code

        except Exception as e:
            print("Error al conectarse a la API:", e)
            return None

    def generate_credit_note_ticket(self, customer_rut, code, dte_type_id):
        TOKEN = "JXou3uyrc7sNnP2ewOCX38tWZ6BTm4D1"

        data = {
            "emisor": "76063822-6",
            "receptor": customer_rut,
            "dte": 61,
            "codigo": code
        }

        print(data)

        try:
            # Endpoint para generar un DTE temporal
            url = f"https://libredte.cl/api/dte/documentos/generar?getXML=0&links=0&email=1&retry=1&gzip=0"
            
            # Enviar solicitud a la API
            response = requests.post(
                url,
                json=data,
                headers={
                    "Authorization": f"Bearer {TOKEN}",
                    "Content-Type": "application/json",
                },
            )

            if response.status_code == 200:
                dte_data = response.json()
                folio = dte_data.get("folio")

                return folio
            else:
                print("Error al generar el DTE:")
                print(response.status_code, response.json())
                return None

        except Exception as e:
            print("Error al conectarse a la API:", e)
            return None
        
    def download(self, id):
        dte = self.db.query(DteModel).filter(DteModel.id == id).first()

        if dte:
            TOKEN = "JXou3uyrc7sNnP2ewOCX38tWZ6BTm4D1"

            # Endpoint para generar un DTE temporal
            url = f"https://libredte.cl/api/dte/dte_emitidos/pdf/"+ str(dte.dte_type_id) +"/"+ str(dte.folio) +"/76063822-6?formato=general&papelContinuo=0&copias_tributarias=1&copias_cedibles=1&cedible=0&compress=0&base64=0"

            # Enviar solicitud a la API
            response = requests.post(
                url,
                headers={
                    "Authorization": f"Bearer {TOKEN}",
                    "Content-Type": "application/json",
                },
            )

            # Manejar la respuesta
            if response.status_code == 200:
                pdf_content = response.content
                timestamp = datetime.now().strftime("%Y_%m_%d_%H_%M_%S")
                unique_id = uuid.uuid4().hex[:8]  # 8 caracteres únicos
                unique_filename = f"{timestamp}_{unique_id}.pdf"

                # Ruta remota en Azure
                remote_path = f"{unique_filename}"  # Organizar archivos en una carpeta específica

                self.file_class.temporal_upload(pdf_content, remote_path)  # Llamada correcta

                # Descargar archivo desde Azure File Share
                file_contents = self.file_class.download(remote_path)

                # Convertir el contenido del archivo a base64
                encoded_file = base64.b64encode(file_contents).decode('utf-8')

                self.file_class.delete(remote_path)  # Llamada correcta

                # Retornar el nombre del archivo y su contenido como base64
                return {
                    "file_name": unique_filename,
                    "file_data": encoded_file
                }
            else:
                return None
            
    def verify(self, id):
        """
        Actualiza los datos de la patente en la base de datos.
        """
        dte = self.db.query(DteModel).filter(DteModel.id == id).first()
        if not dte:
            raise HTTPException(status_code=404, detail="Dte no encontrado")

        # Actualizar campos
        dte.status_id = 2
        self.db.commit()
        self.db.refresh(dte)